package com.combatsystem.www.service;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

import com.combatsystem.www.model.IOTOperator;
import com.combatsystem.www.model.IotEncryptedMessage;
import com.combatsystem.www.model.UAVOperator;
import com.combatsystem.www.model.UavEncryptedMessage;
import com.combatsystem.www.repository.IOTOperatorRepo;
import com.combatsystem.www.repository.IotEncryptedMessageRepository;

import jakarta.transaction.Transactional;

@Service
public class IOTOperatorService {

    @Autowired
    private IOTOperatorRepo iotRepository;

    @Autowired
    private JavaMailSender mailSender;
   
    @Autowired
    private IotEncryptedMessageRepository iotRepo;
    
    @Autowired
    private EncryptionUtils encryptionUtils;
    
    // Store OTPs temporarily (email -> OTP)
    private Map<String, String> otpStorage = new HashMap<>();
    private Map<String, Boolean> verifiedEmails = new HashMap<>();

    // Step 1: Send OTP
    public String sendOtp(String email) {
    	
        if (iotRepository.findByEmail(email) != null) {
            return "Email already registered.";
        }

        String otp = String.format("%06d", new Random().nextInt(999999));
        otpStorage.put(email, otp);
        verifiedEmails.put(email, false); // not verified yet

        sendOtpEmail(email, otp);
        return "OTP sent to your email.";
    }
    
    public String sendLoginOtp(String email) {
        IOTOperator operator = iotRepository.findByEmail(email);

        if (operator == null) {
            return "Email not registered.";
        }

        String otp = String.format("%06d", new Random().nextInt(999999));

        operator.setOtp(otp);  // save OTP to DB for verification
        iotRepository.save(operator);

        sendOtpEmail(email, otp);
        return "OTP sent for login.";
    }

    // Step 2: Verify OTP
    public boolean verifyOtp(String email, String inputOtp) {
        String storedOtp = otpStorage.get(email);
        if (storedOtp != null && storedOtp.equals(inputOtp)) {
            verifiedEmails.put(email, true); // mark email as verified
            otpStorage.remove(email); // optional: clear OTP after use
            return true;
        }
        return false;
    }

    // Step 3: Register user (only after OTP verified)
    @Transactional
    public String registerOperator(IOTOperator operator) {
        if (iotRepository.findByEmail(operator.getEmail()) != null) {
            return "Email already registered.";
        }

        operator.setOtp(null);
        operator.setOtpVerified(true);

        iotRepository.save(operator);

        return "Registration successful!";
    }



    private void sendOtpEmail(String toEmail, String otp) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(toEmail);
        message.setSubject("OTP Verification");
        message.setText("Your OTP is: " + otp);
        mailSender.send(message);
    }

    // Optional: To check if email is verified
    public boolean isEmailVerified(String email) {
        return verifiedEmails.getOrDefault(email, false);
    }

    public void clearVerification(String email) {
        verifiedEmails.remove(email);
    }
    
    public boolean emailExists(String email) {
        return iotRepository.findByEmail(email) != null;
    }

    public List<IOTOperator> getPendingOperators() {
        return iotRepository.findByStatus("PENDING");
    }

    public List<IOTOperator> getDeniedOperators() {
        return iotRepository.findByStatus("DENIED");
    }

    public List<IOTOperator> getApprovedOperators() {
        return iotRepository.findByStatus("APPROVED");
    }

    public String login(String email, String password, String otp) {
        IOTOperator iotOperator = iotRepository.findByEmail(email);

        if (iotOperator == null) {
            return "User not found";
        }

        if (iotOperator.getPassword() == null || !iotOperator.getPassword().equals(password)) {
            return "Invalid Password";
        }

        switch (iotOperator.getStatus()) {
            case "PENDING":
                return "wait for admin approval";
            case "DENIED":
                return "Admin denied your request.";
            case "APPROVED":
                // Now check OTP only if status is APPROVED
                if (iotOperator.getOtp() == null || !iotOperator.getOtp().equals(otp)) {
                    return "Invalid OTP";
                }
                return "SUCCESS";
            default:
                return "Invalid status.";
        }
    }

    public void saveEncryptedMessage(String message, String latitude, String longitude,String email) {
        // Encrypt and split message
        String encryptedMessage = encryptionUtils.encrypt(message);
        Map<String, String> messageBlocks = encryptionUtils.splitMessage(encryptedMessage);

        // Encrypt and split latitude
        String encryptedLatitude = encryptionUtils.encrypt(latitude);
        Map<String, String> latitudeBlocks = encryptionUtils.splitMessage(encryptedLatitude);

        // Encrypt and split longitude
        String encryptedLongitude = encryptionUtils.encrypt(longitude);
        Map<String, String> longitudeBlocks = encryptionUtils.splitMessage(encryptedLongitude);

        IOTOperator operator = iotRepository.findByEmail(email);
        if (operator == null) {
            throw new RuntimeException("Operator not found with email: " + email);
        }
        // Save to entity
        IotEncryptedMessage msg = new IotEncryptedMessage();
        msg.setBlock1(messageBlocks.get("block1"));
        msg.setBlock2(messageBlocks.get("block2"));
        msg.setBlock3(messageBlocks.get("block3"));

        msg.setLatitudeBlock1(latitudeBlocks.get("block1"));
        msg.setLatitudeBlock2(latitudeBlocks.get("block2"));
        msg.setLatitudeBlock3(latitudeBlocks.get("block3"));

        msg.setLongitudeBlock1(longitudeBlocks.get("block1"));
        msg.setLongitudeBlock2(longitudeBlocks.get("block2"));
        msg.setLongitudeBlock3(longitudeBlocks.get("block3"));
        msg.setIotOperator(operator);
        iotRepo.save(msg);
    }


    public String getOriginalMessage(Long id) {
        IotEncryptedMessage msg = iotRepo.findById(id).orElseThrow();
        String encrypted = encryptionUtils.combineBlocks(msg.getBlock1(), msg.getBlock2(), msg.getBlock3());
        return encryptionUtils.decrypt(encrypted);
    }

    public String getLatitude(Long id) {
        IotEncryptedMessage msg = iotRepo.findById(id).orElseThrow();
        String encrypted = encryptionUtils.combineBlocks(
            msg.getLatitudeBlock1(), msg.getLatitudeBlock2(), msg.getLatitudeBlock3());
        return encryptionUtils.decrypt(encrypted);
    }

    public String getLongitude(Long id) {
        IotEncryptedMessage msg = iotRepo.findById(id).orElseThrow();
        String encrypted = encryptionUtils.combineBlocks(
            msg.getLongitudeBlock1(), msg.getLongitudeBlock2(), msg.getLongitudeBlock3());
        return encryptionUtils.decrypt(encrypted);
    }
    
}
