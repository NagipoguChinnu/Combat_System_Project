package com.combatsystem.www.service;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Random;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

import com.combatsystem.www.dto.MessageDto;
import com.combatsystem.www.model.UAVOperator;
import com.combatsystem.www.model.UavEncryptedMessage;
import com.combatsystem.www.repository.UAVOperatorRepo;
import com.combatsystem.www.repository.UavEncryptedMessageRepository;

import jakarta.transaction.Transactional;

@Service
public class UAVOperatorService {

    @Autowired
    private UAVOperatorRepo uavRepository;

    @Autowired
    private JavaMailSender mailSender;
    
    @Autowired
    private UavEncryptedMessageRepository uavRepo;
    
    @Autowired
    private EncryptionUtils encryptionUtils;
    
 
    private MessageDto dto;
    // Store OTPs temporarily (email -> OTP)
    private Map<String, String> otpStorage = new HashMap<>();
    private Map<String, Boolean> verifiedEmails = new HashMap<>();

    // Step 1: Send OTP
    public String sendOtp(String email) {
    	
        if (uavRepository.findByEmail(email) != null) {
            return "Email already registered.";
        }

        String otp = String.format("%06d", new Random().nextInt(999999));
        otpStorage.put(email, otp);
        verifiedEmails.put(email, false); // not verified yet

        sendOtpEmail(email, otp);
        return "OTP sent to your email.";
    }
    
    public String sendLoginOtp(String email) {
        UAVOperator operator = uavRepository.findByEmail(email);

        if (operator == null) {
            return "Email not registered.";
        }

        String otp = String.format("%06d", new Random().nextInt(999999));

        operator.setOtp(otp);  // save OTP to DB for verification
        uavRepository.save(operator);

        sendOtpEmail(email, otp);
        return "OTP sent for login.";
    }

    // Step 2: Verify OTP
    public boolean verifyOtp(String email, String inputOtp) {
        String storedOtp = otpStorage.get(email);
        if (storedOtp != null && storedOtp.equals(inputOtp)) {
            verifiedEmails.put(email, true); // mark email as verified
            otpStorage.remove(email); // optional: clear OTP after use
            return true;
        }
        return false;
    }

    // Step 3: Register user (only after OTP verified)
    @Transactional
    public String registerOperator(UAVOperator operator) {
        if (uavRepository.findByEmail(operator.getEmail()) != null) {
            return "Email already registered.";
        }

        operator.setOtp(null);
        operator.setOtpVerified(true);

        uavRepository.save(operator);

        return "Registration successful!";
    }



    private void sendOtpEmail(String toEmail, String otp) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(toEmail);
        message.setSubject("OTP Verification");
        message.setText("Your OTP is: " + otp);
        mailSender.send(message);
    }

    // Optional: To check if email is verified
    public boolean isEmailVerified(String email) {
        return verifiedEmails.getOrDefault(email, false);
    }

    public void clearVerification(String email) {
        verifiedEmails.remove(email);
    }
    
    public boolean emailExists(String email) {
        return uavRepository.findByEmail(email) != null;
    }

    public List<UAVOperator> getPendingOperators() {
        return uavRepository.findByStatus("PENDING");
    }

    public List<UAVOperator> getDeniedOperators() {
        return uavRepository.findByStatus("DENIED");
    }

    public List<UAVOperator> getApprovedOperators() {
        return uavRepository.findByStatus("APPROVED");
    }

    public String login(String email,String password,String otp)
    {
    	UAVOperator uavOperator=uavRepository.findByEmail(email);
    	
    	if (uavOperator == null) {
            return "User not found";
        }

        if (uavOperator.getPassword() == null || !uavOperator.getPassword().equals(password)) {
            return "Invalid Password";
        }
        if (uavOperator.getOtp() == null || !uavOperator.getOtp().equals(otp)) {
            return "Invalid OTP";
        }
    	System.out.println("otp is "+uavOperator.getOtp());
    	switch(uavOperator.getStatus())
    	{
    	case "PENDING" : return "wait for admin approval";
    	case "APPROVED" : return "SUCCESS";
    	case "DENIED": return "Admin denied your request.";
    	case "BLOCKED":return "Your account was blocked due to multiple invalid OTP attempts";
    	default : return "Invald status.";
    	}
    }
    
    public void saveEncryptedMessage(String message, String latitude, String longitude, String email) {
        // Encrypt and split message
        String encryptedMessage = encryptionUtils.encrypt(message);
        Map<String, String> messageBlocks = encryptionUtils.splitMessage(encryptedMessage);

        // Encrypt and split latitude
        String encryptedLatitude = encryptionUtils.encrypt(latitude);
        Map<String, String> latitudeBlocks = encryptionUtils.splitMessage(encryptedLatitude);

        // Encrypt and split longitude
        String encryptedLongitude = encryptionUtils.encrypt(longitude);
        Map<String, String> longitudeBlocks = encryptionUtils.splitMessage(encryptedLongitude);

        // Fetch operator using email
        UAVOperator operator = uavRepository.findByEmail(email);
        if (operator == null) {
            throw new RuntimeException("Operator not found with email: " + email);
        }

        // Save to entity
        UavEncryptedMessage msg = new UavEncryptedMessage();
        msg.setBlock1(messageBlocks.get("block1"));
        msg.setBlock2(messageBlocks.get("block2"));
        msg.setBlock3(messageBlocks.get("block3"));

        msg.setLatitudeBlock1(latitudeBlocks.get("block1"));
        msg.setLatitudeBlock2(latitudeBlocks.get("block2"));
        msg.setLatitudeBlock3(latitudeBlocks.get("block3"));

        msg.setLongitudeBlock1(longitudeBlocks.get("block1"));
        msg.setLongitudeBlock2(longitudeBlocks.get("block2"));
        msg.setLongitudeBlock3(longitudeBlocks.get("block3"));

        msg.setUavOperator(operator); // Set relation
        uavRepo.save(msg);
    }



    public String getOriginalMessage(Long id) {
        UavEncryptedMessage msg = uavRepo.findById(id).orElseThrow();
        String encrypted = encryptionUtils.combineBlocks(msg.getBlock1(), msg.getBlock2(), msg.getBlock3());
        return encryptionUtils.decrypt(encrypted);
    }

    public String getLatitude(Long id) {
        UavEncryptedMessage msg = uavRepo.findById(id).orElseThrow();
        String encrypted = encryptionUtils.combineBlocks(
            msg.getLatitudeBlock1(), msg.getLatitudeBlock2(), msg.getLatitudeBlock3());
        return encryptionUtils.decrypt(encrypted);
    }

    public String getLongitude(Long id) {
        UavEncryptedMessage msg = uavRepo.findById(id).orElseThrow();
        String encrypted = encryptionUtils.combineBlocks(
            msg.getLongitudeBlock1(), msg.getLongitudeBlock2(), msg.getLongitudeBlock3());
        return encryptionUtils.decrypt(encrypted);
    }
    
    @Transactional
    public void markMessageAsHacked(Long messageId) {
        UavEncryptedMessage message = uavRepo.findById(messageId)
                .orElseThrow(() -> new RuntimeException("Message not found with id: " + messageId));

        message.setStatus("AHACKED"); // make sure your entity has this field
        uavRepo.save(message);
    }

}
