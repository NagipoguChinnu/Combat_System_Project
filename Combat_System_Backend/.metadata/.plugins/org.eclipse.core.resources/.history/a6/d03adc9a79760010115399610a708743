package com.combatsystem.www.service;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Random;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

import com.combatsystem.www.dto.SoldierDto;
import com.combatsystem.www.model.Soldier;
import com.combatsystem.www.model.SoldierEncryptedMessage;
import com.combatsystem.www.repository.SoldierEncryptedRepository;
import com.combatsystem.www.repository.SoldierRepo;

import jakarta.transaction.Transactional;

@Service
public class SoldierService {

    @Autowired
    private SoldierRepo soldierRepository;

    @Autowired
    private JavaMailSender mailSender;
    @Autowired
    private SoldierEncryptedRepository soldierRepo;
    
    @Autowired
    private EncryptionUtils encryptionUtils;
    
    // Store OTPs temporarily (email -> OTP)
    private Map<String, String> otpStorages = new HashMap<>();
    private Map<String, Boolean> verifiedEmail = new HashMap<>();

    // Step 1: Send OTP
    public String sendOtp(String email) {
    	
        if (soldierRepository.findByEmail(email) != null) {
            return "Email already registered.";
        }

        String otp = String.format("%06d", new Random().nextInt(999999));
        otpStorages.put(email, otp);
        verifiedEmail.put(email, false); // not verified yet

        sendOtpEmail(email, otp);
        return "OTP sent to your email.";
    }
    
    public String sendLoginOtp(String email) {
        Soldier operator = soldierRepository.findByEmail(email);

        if (operator == null) {
            return "Email not registered.";
        }

        String otp = String.format("%06d", new Random().nextInt(999999));

        operator.setOtp(otp);  // save OTP to DB for verification
        soldierRepository.save(operator);

        sendOtpEmail(email, otp);
        return "OTP sent for login.";
    }

    // Step 2: Verify OTP
    public boolean verifyOtp(String email, String inputOtp) {
        String storedOtp = otpStorages.get(email);
        if (storedOtp != null && storedOtp.equals(inputOtp)) {
            verifiedEmail.put(email, true); // mark email as verified
            otpStorages.remove(email); // optional: clear OTP after use
            return true;
        }
        return false;
    }

    // Step 3: Register user (only after OTP verified)
    @Transactional
    public String registerOperator(Soldier operator) {
        if (soldierRepository.findByEmail(operator.getEmail()) != null) {
            return "Email already registered.";
        }

        operator.setOtp(null);
        operator.setOtpVerified(true);

        soldierRepository.save(operator);

        return "Registration successful!";
    }



    private void sendOtpEmail(String toEmail, String otp) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(toEmail);
        message.setSubject("OTP Verification");
        message.setText("Your OTP is: " + otp);
        mailSender.send(message);
    }

    // Optional: To check if email is verified
    public boolean isEmailVerified(String email) {
        return verifiedEmail.getOrDefault(email, false);
    }

    public void clearVerification(String email) {
        verifiedEmail.remove(email);
    }
    
    public boolean emailExists(String email) {
        return soldierRepository.findByEmail(email) != null;
    }

    public List<SoldierDto> getPendingOperators() {
    	return soldierRepository.findByStatus("PENDING").stream()
                .map(s -> new SoldierDto(
                    s.getId(),
                    s.getUserName(),
                    s.getEmail(),
                    s.getDeviceType(),
                    s.getLatitude(),
                    s.getLongitude()
                ))
                .collect(Collectors.toList());
    }


    public List<SoldierDto> getDeniedOperators() {
    	return soldierRepository.findByStatus("DENIED").stream()
                .map(s -> new SoldierDto(
                    s.getId(),
                    s.getUserName(),
                    s.getEmail(),
                    s.getDeviceType(),
                    s.getLatitude(),
                    s.getLongitude()
                ))
                .collect(Collectors.toList());
    }

    public List<SoldierDto> getApprovedOperators() {
        return soldierRepository.findByStatus("APPROVED").stream()
            .map(s -> new SoldierDto(
                s.getId(),
                s.getUserName(),
                s.getEmail(),
                s.getDeviceType(),
                s.getLatitude(),
                s.getLongitude()
            ))
            .collect(Collectors.toList());
    }


    public String login(String email,String password,String otp)
    {
    	Soldier soldier=soldierRepository.findByEmail(email);
    	
    	if (soldier == null) {
            return "User not found";
        }

        if (soldier.getPassword() == null || !soldier.getPassword().equals(password)) {
            return "Invalid Password";
        }
        if (soldier.getOtp() == null || !soldier.getOtp().equals(otp)) {
            return "Invalid OTP";
        }
    	System.out.println("otp is "+soldier.getOtp());
    	switch(soldier.getStatus())
    	{
    	case "PENDING" : return "wait for admin approval";
    	case "APPROVED" : return "SUCCESS";
    	case "DENIED": return "Admin denied your request.";
    	case "BLOCKED":return "Your account was blocked due to multiple invalid OTP attempts";
    	default : return "Invald status.";
    	}
    }
    
    public void saveEncryptedMessage(String message, String latitude, String longitude, String email) {
        // Encrypt and split message
        String encryptedMessage = encryptionUtils.encrypt(message);
        Map<String, String> messageBlocks = encryptionUtils.splitMessage(encryptedMessage);

        // Encrypt and split latitude
        String encryptedLatitude = encryptionUtils.encrypt(latitude);
        Map<String, String> latitudeBlocks = encryptionUtils.splitMessage(encryptedLatitude);

        // Encrypt and split longitude
        String encryptedLongitude = encryptionUtils.encrypt(longitude);
        Map<String, String> longitudeBlocks = encryptionUtils.splitMessage(encryptedLongitude);

        Soldier operator = soldierRepository.findByEmail(email);
        if (operator == null) {
            throw new RuntimeException("Operator not found with email: " + email);
        }
        // Save to entity
        SoldierEncryptedMessage msg = new SoldierEncryptedMessage();
        msg.setBlock1(messageBlocks.get("block1"));
        msg.setBlock2(messageBlocks.get("block2"));
        msg.setBlock3(messageBlocks.get("block3"));

        msg.setLatitudeBlock1(latitudeBlocks.get("block1"));
        msg.setLatitudeBlock2(latitudeBlocks.get("block2"));
        msg.setLatitudeBlock3(latitudeBlocks.get("block3"));

        msg.setLongitudeBlock1(longitudeBlocks.get("block1"));
        msg.setLongitudeBlock2(longitudeBlocks.get("block2"));
        msg.setLongitudeBlock3(longitudeBlocks.get("block3"));
        msg.setSoldierOperator(operator);
        soldierRepo.save(msg);
    }


    public String getOriginalMessage(Long id) {
        SoldierEncryptedMessage msg = soldierRepo.findById(id).orElseThrow();
        String encrypted = encryptionUtils.combineBlocks(msg.getBlock1(), msg.getBlock2(), msg.getBlock3());
        return encryptionUtils.decrypt(encrypted);
    }

    public String getLatitude(Long id) {
        SoldierEncryptedMessage msg = soldierRepo.findById(id).orElseThrow();
        String encrypted = encryptionUtils.combineBlocks(
            msg.getLatitudeBlock1(), msg.getLatitudeBlock2(), msg.getLatitudeBlock3());
        return encryptionUtils.decrypt(encrypted);
    }

    public String getLongitude(Long id) {
        SoldierEncryptedMessage msg = soldierRepo.findById(id).orElseThrow();
        String encrypted = encryptionUtils.combineBlocks(
            msg.getLongitudeBlock1(), msg.getLongitudeBlock2(), msg.getLongitudeBlock3());
        return encryptionUtils.decrypt(encrypted);
    }
    
    public SoldierDto getSoldierByEmail(String email) {
        return soldierRepository.findFirstByEmail(email);
               
    }
  
}
