package com.combatsystem.www.controller;

import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.combatsystem.www.dto.MessageDto;
import com.combatsystem.www.dto.SoldierDto;
import com.combatsystem.www.model.Soldier;
import com.combatsystem.www.model.SoldierEncryptedMessage;
import com.combatsystem.www.repository.SoldierEncryptedRepository;
import com.combatsystem.www.repository.SoldierRepo;
import com.combatsystem.www.service.OtpService;
import com.combatsystem.www.service.SoldierService;


@RestController
@RequestMapping("/soldier")
@CrossOrigin(origins = "http://localhost:3000")
public class SoldierController {

    @Autowired
    private OtpService otpService;

    @Autowired
    private SoldierService soldierService;

    @Autowired
    private SoldierRepo soldierRepository;
    
    @Autowired
    private SoldierEncryptedRepository repo;

    // Send OTP
    @PostMapping("/send-otp")
    public ResponseEntity<String> sendOtp(@RequestParam String email) {
        otpService.generateAndSendOtp(email);
        return ResponseEntity.ok("OTP sent to " + email);
    }

    @PostMapping("/send-login-otp")
    public ResponseEntity<String> sendLoginOtp(@RequestParam String email) {
        String response = soldierService.sendLoginOtp(email);
        return ResponseEntity.ok(response);
    }
    
    // Verify OTP
    @PostMapping("/verify-otp")
    public ResponseEntity<String> verifyOtp(@RequestParam String email, @RequestParam String otp) {
    	System.out.println("Verifying OTP for email: " + email + ", OTP: " + otp);
        if (otpService.verifyOtp(email, otp)) {
            return ResponseEntity.ok("OTP verified successfully");
        } else {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Invalid OTP");
        }
    }


    // Register Operator
    @PostMapping("/register")
    public ResponseEntity<String> register(@RequestBody Soldier operator) {
        if (soldierService.emailExists(operator.getEmail())) {
            return ResponseEntity.status(HttpStatus.CONFLICT).body("Email already registered");
        }

        if (!otpService.isEmailVerified(operator.getEmail())) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Email not verified");
        }

        operator.setStatus("PENDING");
        soldierService.registerOperator(operator);
        otpService.clearVerification(operator.getEmail());
        soldierRepository.save(operator);

        return ResponseEntity.ok("Registration request submitted. Awaiting admin approval.");
    }

    // Get all operators
    @GetMapping("/all")
    public List<Soldier> getAllUavOperators() {
        return soldierRepository.findAll();
    }

    // Get pending operators
    @GetMapping("/pending")
    public ResponseEntity<List<Soldier>> getPendingOperators() {
        return ResponseEntity.ok(soldierService.getPendingOperators());
    }

    // Get approved operators
    @GetMapping("/approved")
    public ResponseEntity<List<SoldierDto>> getApprovedOperators() {
        return ResponseEntity.ok(soldierService.getApprovedOperators());
    }

    // Get denied operators
    @GetMapping("/denied")
    public ResponseEntity<List<Soldier>> getDeniedOperators() {
        return ResponseEntity.ok(soldierService.getDeniedOperators());
    }

    // Reusable: Get operators by any status
    @GetMapping("/status/{status}")
    public ResponseEntity<List<Soldier>> getOperatorsByStatus(@PathVariable String status) {
        return ResponseEntity.ok(soldierRepository.findByStatus(status.toUpperCase()));
    }
    
    @PostMapping("/login")
    public ResponseEntity<String> login(@RequestBody Map<String, String> request) {
        try {
            String email = request.get("email");
            String password = request.get("password");
            String otp = request.get("otp");

            String response = soldierService.login(email, password, otp);
            
            if ("SUCCESS".equals(response)) {
                return ResponseEntity.ok("Login Successful");
            } else {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
            }
        } catch (Exception e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                                 .body("Something went wrong on the server.");
        }
    }

    @PostMapping("/login-request")
    public ResponseEntity<String> loginRequest(@RequestBody Map<String, String> payload) {
        String email = payload.get("email");
        String password = payload.get("password");
        
        System.out.println("Received email: " + email);
        System.out.println("Received password: " + password);

        if (email == null || password == null) {
            return ResponseEntity.badRequest().body("Email and password are required");
        }

        Soldier operator = soldierRepository.findByEmail(email);

        if (operator == null) {
            return ResponseEntity.badRequest().body("Invalid email or password");
        }

        System.out.println("DB password: " + operator.getPassword());
        System.out.println("DB email: " + operator.getEmail());

        if (!operator.getPassword().equals(password)) {
            return ResponseEntity.badRequest().body("Invalid email or password");
        }

        // Email & password match â€” send OTP
        otpService.generateAndSendOtp(email);
        return ResponseEntity.ok("OTP sent to " + email);
    }

    @PostMapping("/sendinfo")
    public ResponseEntity<String> receiveEncryptedInfo(@RequestBody MessageDto info) {
        if (info.getMessage() == null || info.getLatitude() == null || info.getLongitude() == null) {
            return ResponseEntity.badRequest().body("All fields (message, latitude, longitude) are required.");
        }
        soldierService.saveEncryptedMessage(info.getMessage(), info.getLatitude(), info.getLongitude(), info.getEmail());
        return ResponseEntity.ok("Encrypted Message Stored Successfully");
    }
}
